import cas.test.commons.*;  
SYSTEM: {
	name: "GameOfLife_SG";  
    
	description: ""; 
	ruleset: {     
		type: lenient;   
		inspection_level: strong;   
		lenient_exceptions: diversity modularity;
		semantic_groups: enable; 
	};
	       
	parameters: { 
		//Items with * will be generated in the initialization file
	 	var * int:numCellCitiesX = 10; 
	 	var * int:numCellCitiesY = 10;   
	 	var * int:numCellsPerCityX = 10;
	 	var * int:numCellsPerCityY = 10;
	 	var * int:numCellMegaCitiesX = 1;
	 	var * int:numCellMegaCitiesY = 1;
	 	 
	 	//These are standard parameters.
	 	var Vector2:numberOfCellMegaCities; 
	 	var Vector2:numCellCities;
	 	var Vector2:numCellsPerCity;
	 	var Grid<env.TheEnvironment>:CellMegaCityGrid;
	 	var LayoutParameters:layoutParameters;
	};  
  
	functions: {
		def initialize()(): {
			self.numCellCities.setPair(self.numCellCitiesX,self.numCellCitiesY);
			self.numCellsPerCity.setPair(self.numCellsPerCityX,self.numCellsPerCityY);
			
			self.layoutParameters.addEntityType(GROUP.CellCity);
			CellMegaCityGrid.init(self.numberOfCellMegaCities, self.layoutParameters); 
			CellMegaCityGrid.place();
			CellMegaCityGrid.initCells(self.numCellCities, self.numCellsPerCity, self.layoutParameters);
			self.layoutParameters.addContainedEntities(self.CellMegaCityGrid);

		};
	}; 
	agent_types: { 
		Cell; 		
	};
	            
	group_types: { 	 
		CellCity; 
	}; 

	environment_types: {
		TheEnvironment;  
	};  
 
	end_conditions: { 
		condition STEPS steps;
	};
};

AGENT Cell: {
	description: "A cell"; 

	parameters: {
		var bool:Alive = false; 
		grp CellCity:theCity;  
		var Vector2:cellPosition;
		
	};      
 
	functions: { 
		def initialize()(): {}; 
		 
		def setPosition(var Vector2:pos)(): {
			self.cellPosition = pos;
		};
  
		def setState(var bool:state)(): {
			self.Alive = state;
		};
	};    
   
	behaviors: {
		changeStateToDead[SELF][DELAYED](): { 
			self.Alive = false;		
		};
		changeStateToAlive[SELF][DELAYED](): { 
			self.Alive = true; 
		}; 
 
		doStep[AGENT][REPEAT(1)](): {
			var List<agt.Cell>:listOfNeighbors = INTERACTION.findNeighbors();
			var int:aliveNeighbors = 0;
			foreach(i :listOfNeighbors) do
				INTERACTION.checkIfAlive(i);
			endfor;
		};
	};  
  
	interactions: {		
		findNeighbors[QUERY][INPUT()](): {
			var List<agt.Cell>:neighborsList = self.theCity.GRP_INTERNAL.getNeighbours(self.cellPosition); 
		};  
		 
		checkIfAlive[QUERY][INPUT()](agt Cell:c): {
			CASL.METRIC[true];  
			if (c.AGT_INTERACTION.amIAlive()) then  
				1;
			else  
				0;   
			endif;			
			 
		};		    
		amIAlive[QUERY][INPUT()](): {
			self.Alive; 
		};
		 		
		//Should this return something?
		test[QUERY][INPUT()](agt Cell:c): { 
			theCity.GRP_INTERNAL.getNeighbours(self.cellPosition);
			CASL.METRIC[true];  
		};
		
	}; 
 
	adaptation: { 
		stateAdaptation[IMPLICIT][NONE](var int:neighbors): {
			if (self.Alive) then
				if (neighbors >= 2 && neighbors <= 3) then 
					BEHAVIOR.changeStateToDead();
				endif;
			else
				if (neighbors== 3) then
					BEHAVIOR.changeStateToAlive();
				endif;
			endif; 
		};
	};
	subsystems: {};   
};   

GROUP CellCity: {
	description: "A CellCity";	
	group_rules: {
		layout_type: GRID;
	}; 
	parameters: {
		env TheEnvironment:theEnv;
		var Neighbors<grp.CellCity>:neighbors;
		
		//Setting up representation   
		var Grid<agt.Cell>:cellGrid;
		var Vector2:numberOfCells;
		var LayoutParameters:layoutParameters;
		var Vector2:cellCityPosition;   
	};    
	functions: {  
		def initialize(var Vector2:cells)(): {
			self.layoutParameters.addEntityType(AGENT.Cell); 
			self.numberOfCells = SYSTEM.numCellCities; 
			self.cellGrid.init(self.numberOfCells, layoutParameters);
			self.layoutParameters.addContainedEntities(self.cellGrid);
		}; 
	}; 
	behaviors: {};
	transmissions: {
		 getCellCityNeighbours[SETUP][STATE][REPEAT (1)](): {  
			//Edges  
			grp CellCity:ccL = self.neighbors.getL();
			ccL.GRP_TRANSMISSION.receiveStates(theEnv.ENV_INTERACTION.receiveStates(ENUM.GridPositions.LEFT, cellGrid.getAll(ENUM.GridPositions.LEFT)));
			
			grp CellCity:ccR = self.neighbors.getR();
			ccR.GRP_TRANSMISSION.receiveStates(theEnv.ENV_INTERACTION.receiveStates(ENUM.GridPositions.RIGHT,cellGrid.getAll(ENUM.GridPositions.RIGHT)));
			
			grp CellCity:ccD = self.neighbors.getD();
			ccD.GRP_TRANSMISSION.receiveStates(theEnv.ENV_INTERACTION.receiveStates(ENUM.GridPositions.DOWN,cellGrid.getAll(ENUM.GridPositions.TOP)));
			
			grp CellCity:ccU = self.neighbors.getU();
			ccU.GRP_TRANSMISSION.receiveStates(theEnv.ENV_INTERACTION.receiveStates(ENUM.GridPositions.UP,cellGrid.getAll(ENUM.GridPositions.BOTTOM)));
			
			//Corners
			grp CellCity:ccUL = self.neighbors.getUL();
			ccUL.GRP_TRANSMISSION.receiveStates(theEnv.ENV_INTERACTION.receiveStates(ENUM.GridPositions.UPLEFT,cellGrid.getAll(ENUM.GridPositions.TOPLEFT)));
			
			grp CellCity:ccUR = self.neighbors.getUR();
			ccUR.GRP_TRANSMISSION.receiveStates(theEnv.ENV_INTERACTION.receiveStates(ENUM.GridPositions.UPRIGHT,cellGrid.getAll(ENUM.GridPositions.TOPRIGHT)));
			
			grp CellCity:ccDL = self.neighbors.getDL();
			ccDL.GRP_TRANSMISSION.receiveStates(theEnv.ENV_INTERACTION.receiveStates(ENUM.GridPositions.DOWNLEFT,cellGrid.getAll(ENUM.GridPositions.BOTTOMLEFT)));
			
			grp CellCity:ccDR = self.neighbors.getDR();
			ccDR.GRP_TRANSMISSION.receiveStates(theEnv.ENV_INTERACTION.receiveStates(ENUM.GridPositions.DOWNRIGHT,cellGrid.getAll(ENUM.GridPositions.BOTTOMRIGHT)));			
		}; 

		receiveStates[SETUP][AGENT][SINGLE](var GridPositions:gp, var List<agt.Cell>:neighbors): {
			self.cellGrid.addPhantomCells(gp,neighbors);
		};		 
		
		getNeighboursOfCellCity[SETUP][AGENT][SINGLE](var Vector2:thisPos): {
			self.neighbors = theEnv.ENV_INTERACTION.receiveCityNeighbours(thisPos);
		};
	}; 
	internals: {
		getNeighbours[QUERY][INPUT(1)](var Vector2:cellPos): {
			var List<agt.Cell>:neighbors = self.cellGrid.getNeighboursFromVector(cellPos, 1);
		};
	};  
}; 

ENVIRONMENT TheEnvironment: {
	description: "";
	environment_rules: {
		type: implicit
		attributes: virtual
		layout_type: GRID;
	};          
	parameters: {
		var LayoutParameters:layoutParameters;
		var Vector2:numberOfCellCities;
		var Vector2:cellsPerCity;
		var Grid<grp.CellCity>:CellCityGrid;
		grp CellCity:cellCity;
	};
	functions: {
		def initialize(var Vector2:numberOfCellCities, var Vector2:cellsPerCity, var LayoutParameters:layoutParameters)(): {
			self.numberOfCellCities = numberOfCellCities;
			self.cellsPerCity = cellsPerCity;
			self.layoutParameters = layoutParameters;
			self.layoutParameters.addEntityType(GROUP.CellCity);
			CellCityGrid.init(self.numberOfCellCities, self.layoutParameters);
			CellCityGrid.place();
			CellCityGrid.initCells(self.cellsPerCity);
			self.layoutParameters.addContainedEntities(self.CellCityGrid);
		}; 
	}; 
	behaviors: {}; 
	interactions: {
		receiveStates[COMMUNICATION][INPUT(1)](var GridPositions:gp, var List<agt.Cell>:neighbors): {
			CellCityGrid.send(gp, neighbors, "receiveStates");
		};
		
		receiveCityNeighbours[COMMUNICATION][INPUT(1)](var Vector2:pos): {			
			var Neighbors<grp.CellCity>:neighbors = self.CellCityGrid.getNeighboursFromVector(pos, 1);
		};
	};
	adaptation: {};
	subsystems: {};
	group_interactions: {};
};