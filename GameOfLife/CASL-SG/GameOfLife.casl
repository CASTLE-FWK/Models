import cas.test.commons.*;  
SYSTEM: {
	name: "GameOfLifeSG";  
    
	description: ""; 
	ruleset: {     
		type: lenient;   
		inspection_level: strong;   
		lenient_exceptions: diversity modularity;
		semantic_groups: enable; 
	};
	       
	parameters: { 
		//Items with * will be generated in the initialization file
	 	var * int:numCellCitiesX = 10; 
	 	var * int:numCellCitiesY = 10;   
	 	var * int:numCellsPerCityX = 10;
	 	var * int:numCellsPerCityY = 10;
	 	var * int:numCellMegaCitiesX = 1;
	 	var * int:numCellMegaCitiesY = 1;
	 	var * int:terminationStep = 1000;
	 	 
	 	//These are standard parameters.
	 	var Vector2:numberOfCellMegaCities; 
	 	var Vector2:numCellCities;
	 	var Vector2:numCellsPerCity;  
	 	var Grid<env.CellMegaCity>:CellMegaCityGrid; 
	 	var LayoutParameters:layoutParameters;	 	
	};  
  
	functions: {
		def initialize()(): {
			self.numCellCities.setPair(self.numCellCitiesX,self.numCellCitiesY);
			self.numCellsPerCity.setPair(self.numCellsPerCityX,self.numCellsPerCityY);
			
			self.layoutParameters.addEntityType(ENVIRONMENT.CellMegaCity);
			CellMegaCityGrid.init(self.numberOfCellMegaCities, self.layoutParameters); 
			CellMegaCityGrid.place();
			CellMegaCityGrid.initCells(self.numCellCities, self.numCellsPerCity, self.layoutParameters);
			self.layoutParameters.addContainedEntities(self.CellMegaCityGrid);

		};
	}; 
	agent_types: { 
		Cell; 		
	};
	            
	group_types: { 	 
		CellCity; 
	}; 

	environment_types: {
		CellMegaCity;  
	};  
 
	end_conditions: { 
		condition STEPS terminationStep;
	};
};

AGENT Cell: { 
	description: "A cell"; 

	parameters: {
		var bool:Alive = false; 
		grp CellCity:theCity;  
		var Vector2:cellPosition;
		
	};      
 
	functions: { 
		def initialize(var bool:initialLife)(): {
			self.Alive = initialLife;
		}; 
		 
		def setPosition(var Vector2:pos)(): {
			self.cellPosition = pos;
		};
  
		def setState(var bool:state)(): {
			self.Alive = state;
		};
	};    
   
	behaviors: {
		changeStateToDead[SELF][DELAYED](): {
			FUNCTION.setState(false);
		};
		changeStateToAlive[SELF][DELAYED](): { 
			FUNCTION.setState(true); 
		};
 
		doStep[AGENT][REPEAT(1)](): {
			var List<agt.Cell>:listOfNeighbors = INTERACTION.findNeighbors();
			var int:aliveNeighbors = 0;
			foreach(Cell i : listOfNeighbors) do
				INTERACTION.checkIfAlive(i);
			endfor;
			ADAPTATION.stateAdaptation(aliveNeighbors);
		};
	};  
  
	interactions: {
		findNeighbors[QUERY][INPUT()](): { 
			var List<agt.Cell>:neighborsList = self.theCity.GRP_INT_INTERACTION.getNeighbours(self.cellPosition); 
		};   
		 
		checkIfAlive[QUERY][INPUT()](agt Cell:c): {
			CASL.METRIC[true];  
			if (c.AGT_INTERACTION.amIAlive()) then  
				1;
			else  
				0;   
			endif;			
			 
		};		    
		amIAlive[QUERY][INPUT()](): {
			self.Alive; 
		};		
	}; 
 
	adaptation: { 
		stateAdaptation[IMPLICIT][NONE](var int:neighbors): {
			if (self.Alive) then
				if (neighbors >= 2 && neighbors <= 3) then 
					BEHAVIOR.changeStateToDead();
				endif;
			else
				if (neighbors== 3) then
					BEHAVIOR.changeStateToAlive();
				endif;
			endif; 
		};
	};
	subsystems: {};   
};   
 
GROUP CellCity: {
	description: "A CellCity";	
	group_rules: {
		layout_type: GRID;
	}; 
	parameters: {
		env CellMegaCity:theEnv;
		var Neighbors<grp.CellCity>:neighbors;
		
		//Setting up representation   
		var Grid<agt.Cell>:cellGrid;
		var Vector2:numberOfCells;
		var LayoutParameters:layoutParameters;
		var Vector2:cellCityPosition;
		
		grp CellCity:ccL;
		grp CellCity:ccR;
		grp CellCity:ccD;
		grp CellCity:ccU;
		 
		grp CellCity:ccDL;
		grp CellCity:ccUL; 
		grp CellCity:ccDR;
		grp CellCity:ccUR;
		
	};    
	functions: {  
		def initialize(var Vector2:cells)(): {
			self.layoutParameters.addEntityType(AGENT.Cell); 
			self.numberOfCells = SYSTEM.numCellCities; 
			self.cellGrid.init(self.numberOfCells, layoutParameters);
			self.layoutParameters.addContainedEntities(self.cellGrid);
			self.ccL = self.neighbors.getL();
			self.ccR = self.neighbors.getR();
			self.ccD = self.neighbors.getD();
			self.ccU = self.neighbors.getU();
			self.ccUL = self.neighbors.getUL();
			self.ccUR = self.neighbors.getUR();
			self.ccDL = self.neighbors.getDL();
			self.ccDR = self.neighbors.getDR();
		}; 
	}; 
	behaviors: {};   
	external_interactions: {
		 sendStates[SETUP][STATE][REPEAT (1)](): {  
			//Edges  
			ccL.GRP_EXT_INTERACTION.receiveStates(ENUM.GridPositions.LEFT, cellGrid.getAll(ENUM.GridPositions.LEFT));
			ccR.GRP_EXT_INTERACTION.receiveStates(ENUM.GridPositions.RIGHT,cellGrid.getAll(ENUM.GridPositions.RIGHT));
			ccD.GRP_EXT_INTERACTION.receiveStates(ENUM.GridPositions.DOWN,cellGrid.getAll(ENUM.GridPositions.TOP));
			ccU.GRP_EXT_INTERACTION.receiveStates(ENUM.GridPositions.UP,cellGrid.getAll(ENUM.GridPositions.BOTTOM));
			
			//Corners
			ccUL.GRP_EXT_INTERACTION.receiveStates(ENUM.GridPositions.UPLEFT,cellGrid.getAll(ENUM.GridPositions.TOPLEFT));
			ccUR.GRP_EXT_INTERACTION.receiveStates(ENUM.GridPositions.UPRIGHT,cellGrid.getAll(ENUM.GridPositions.TOPRIGHT));
			ccDL.GRP_EXT_INTERACTION.receiveStates(ENUM.GridPositions.DOWNLEFT,cellGrid.getAll(ENUM.GridPositions.BOTTOMLEFT));
			ccDR.GRP_EXT_INTERACTION.receiveStates(ENUM.GridPositions.DOWNRIGHT,cellGrid.getAll(ENUM.GridPositions.BOTTOMRIGHT));			
		}; 

		receiveStates[SETUP][AGENT][CALLED](var GridPositions:gp, var List<agt.Cell>:neighbors): {
			self.cellGrid.addPhantomCells(gp,neighbors);
		};		 
		
		getNeighboursOfCellCity[SETUP][AGENT][CALLED](var Vector2:thisPos): {
			self.neighbors = theEnv.ENV_INTERACTION.receiveCityNeighbours(thisPos);
		};
	}; 
	internal_interactions: {
		getNeighbours[QUERY][INPUT(1)](var Vector2:cellPos): {
			var List<agt.Cell>:neighbors = self.cellGrid.getNeighboursFromVector(cellPos, 1);
		};
		test[QUERY][INPUT(1)](): {
			
		};
	};  
}; 

ENVIRONMENT CellMegaCity: {
	description: "";
	environment_rules: {
		type: implicit 
		attributes: virtual
		layout_type: GRID;
	};          
	parameters: {
		var LayoutParameters:layoutParameters;
		var Vector2:numberOfCellCities;
		var Vector2:cellsPerCity;
		var Grid<grp.CellCity>:CellCityGrid;
		grp CellCity:cellCity;
	};
	functions: {
		def initialize(var Vector2:numberOfCellCities, var Vector2:cellsPerCity, var LayoutParameters:layoutParameters)(): {
			self.numberOfCellCities = numberOfCellCities;
			self.cellsPerCity = cellsPerCity;
			self.layoutParameters = layoutParameters;
			self.layoutParameters.addEntityType(GROUP.CellCity);
			CellCityGrid.init(self.numberOfCellCities, self.layoutParameters);
			CellCityGrid.place();
			CellCityGrid.initCells(self.cellsPerCity);
			self.layoutParameters.addContainedEntities(self.CellCityGrid);
		}; 
	}; 
	behaviors: {}; 
	interactions: {		
		receiveCityNeighbours[COMMUNICATION][INPUT(1)](var Vector2:pos): {			
			var Neighbors<grp.CellCity>:neighbors = self.CellCityGrid.getNeighboursFromVector(pos, 1);
		};
	};
	adaptation: {};
	subsystems: {};
	group_interactions: {};
};